#![allow(clippy::ptr_arg, clippy::needless_borrow)]

use alloc::rc::Rc;
use std::cell::RefCell;
use std::collections::HashMap;
use std::ops::Add;

//use webinterop::{web_fns, web_interop};
use crate::types::Result;
use crate::web_executor::js::v8::{V8Context, V8Function, V8FunctionVariadic, V8Value, V8VariadicArgsInternal};
use crate::web_executor::js::{Args, JSContext, JSFunction, JSFunctionCallBack, JSFunctionCallBackVariadic, JSFunctionVariadic, JSObject, JSRuntime, JSValue, ValueConversion, VariadicArgs, VariadicArgsInternal};

//#[web_interop]
struct TestStruct {
    //#[property]
    field: i32,

    //#[property]
    field2: HashMap<i32, i32>, //should crash it
}

//#[web_fns]
impl TestStruct {
    fn add(&self, other: i32) -> i32 {
        self.field + other
    }

    fn add2(&mut self, other: i32) {
        self.field += other
    }

    fn add3(a: i32, b: i32) -> i32 {
        a + b
    }
    fn variadic<T: VariadicArgsInternal>(nums: T) {}

    fn v8_variadic(nums: V8Value) {}
}

// #[test]
// fn test() {
//     let test = TestStruct {
//         field: 3,
//         field2: HashMap::new(),
//     };
//
//     let k = test.add(5);
// }

//test, how we need to implement slices and vectors with refs
fn array_test() {
    let mut test_vec = vec![1, 2, 3];

    vec(test_vec.clone()); //clone only needed for the test

    ref_vec(&test_vec);

    mut_vec(&mut test_vec);

    ref_slice(&test_vec);

    mut_slice(&mut test_vec);

    size_slice(<[i32; 3]>::try_from(test_vec.clone()).unwrap()); //clone only needed for the test

    ref_size_slice(&<[i32; 3]>::try_from(test_vec.clone()).unwrap()); //clone only needed for the test

    mut_size_slice(&mut <[i32; 3]>::try_from(test_vec.clone()).unwrap()); //clone only needed for the test
}

fn vec(vec: Vec<i32>) {}

fn ref_vec(vec: &Vec<i32>) {}

fn mut_vec(vec: &mut Vec<i32>) {}

fn ref_slice(slice: &[i32]) {}

fn mut_slice(slice: &mut [i32]) {}

fn size_slice(array: [i32; 3]) {}

fn ref_size_slice(slice: &[i32; 3]) {}

fn mut_size_slice(slice: &mut [i32; 3]) {}

struct Test2 {
    field: i32,
    other_field: String,
}

impl Test2 {
    fn cool_fn(&self) -> i32 {
        self.field
    }

    fn add(&mut self, other: i32) {
        self.field += other;
    }

    fn concat(&self, other: String) -> String {
        self.other_field.clone() + &other
    }

    fn takes_ref(&self, other: &String) -> String {
        self.other_field.clone() + other
    }

    fn variadic<A: VariadicArgs>(&self, nums: &A) {
        for _ in nums.as_vec() {
            println!("got an arg...");
        }
    }
}

impl Test2 {

    //this function will be generated by a macro
    fn implement(s: Rc<RefCell<Self>>, mut ctx: V8Context) -> Result<()> {
        let obj = ctx.new_global_object("test2")?; //#name

        let cool_fn = {
            let s = Rc::clone(&s);
            V8Function::new(ctx.clone(), |cb| {
                //TODO: add R::Function::new
                let num_args = 0; //function.arguments.len();
                if num_args != cb.len() {
                    // cb.error("wrong number of arguments"); //TODO
                    return;
                }

                let ctx = cb.context();

                let Ok(ret) = s.borrow().cool_fn().to_js_value(ctx.clone()) else {
                    // cb.error(e); //TODO
                    return;
                };

                cb.ret(ret);
            })?
        };

        obj.set_method("cool_fn", &cool_fn)?;

        let add = {
            let s = Rc::clone(&s);
            V8Function::new(ctx.clone(),  |cb| {
                let num_args = 1; //function.arguments.len();
                if num_args != cb.len() {
                    // cb.error("wrong number of arguments"); //TODO
                    return;
                }

                let ctx = cb.context();

                let args = cb.args();

                let Some(arg0) = cb.args().get(0, ctx.clone()) else {
                    // cb.error("failed to get argument"); //TODO
                    return;
                };

                let Ok(arg0) = arg0.as_number() else {
                    // cb.error("failed to convert argument"); //TODO
                    return;
                };

                #[allow(clippy::unit_arg)]
                let ret = s
                    .borrow_mut()
                    .add(arg0 as i32)
                    .to_js_value(ctx.clone())
                    .unwrap();

                cb.ret(ret);
            })?
        };
        obj.set_method("add", &add)?;

        let concat = {
            let s = Rc::clone(&s);
            V8Function::new(ctx.clone(), |cb| {
                let num_args = 1; //function.arguments.len();
                if num_args != cb.len() {
                    // cb.error("wrong number of arguments"); //TODO
                    return;
                }

                let ctx = cb.context();

                let args = cb.args();

                let Some(arg0) = cb.args().get(0, ctx.clone()) else {
                    // cb.error("failed to get argument"); //TODO
                    return;
                };

                let Ok(arg0) = arg0.as_string() else {
                    // cb.error("failed to convert argument"); //TODO
                    return;
                };

                let ret = s
                    .borrow()
                    .concat(arg0)
                    .to_js_value(ctx.clone())
                    .unwrap();

                cb.ret(ret);
            })?
        };
        obj.set_method("concat", &concat)?;

        let takes_ref = {
            let s = Rc::clone(&s);
            V8Function::new(ctx.clone(), |cb| {
                let num_args = 1; //function.arguments.len();
                if num_args != cb.len() {
                    // cb.error("wrong number of arguments"); //TODO
                    return;
                }

                let ctx = cb.context();

                let args = cb.args();

                let Some(arg0) = cb.args().get(0, ctx.clone()) else {
                    // cb.error("failed to get argument"); //TODO
                    return;
                };

                let Ok(arg0) = arg0.as_string() else {
                    // cb.error("failed to convert argument"); //TODO
                    return;
                };

                let ret = s
                    .borrow()
                    .takes_ref(&arg0)
                    .to_js_value(ctx.clone())
                    .unwrap();

                cb.ret(ret);
            })?
        };
        obj.set_method("takes_ref", &takes_ref)?;

        let variadic = {
            let s = Rc::clone(&s);
            V8FunctionVariadic::new(ctx.clone(), move |cb| {
                let num_args = 0; //function.arguments.len();
                if num_args != cb.len() {
                    // cb.error("wrong number of arguments"); //TODO
                    return;
                }

                let ctx = cb.context();

                let args = cb.args().variadic(Rc::clone(&ctx));

                #[allow(clippy::unit_arg)]
                let ret = s
                    .borrow()
                    .variadic(&args)
                    .to_js_value(ctx)
                    .unwrap();

                cb.ret(ret);
            })?
        };

        Ok(())
    }
}


#[test]
fn manual_js_inop() {
    let mut engine = crate::web_executor::js::v8::V8Engine::new();
    let mut context = engine.new_context().unwrap();

    let t2 = Rc::new(RefCell::new(Test2 {
        field: 14,
        other_field: "Hello, ".to_string(),
    }));

    Test2::implement(t2, context.clone()).unwrap();

    let out = context.run(r#"
        test2.cool_fn()
    "#).unwrap().as_string().unwrap();

    println!("JS: {}", out);
}